/*----------------------------------------------------------------
 * File:      pth_sample_sort.c
 * Purpose:   Implement a parallel sample sort algorithm that sorts
 *            a list of ints
 * 
 * Compile:   gcc -g -Wall -o pth_sample_sort pth_sample_sort.c -lpthread -lm
 * Run:       ./pth_sample_sort <number of threads> <n> <s> <modulus> 
 *             n:       number of elements in the list
 *             s:       sample size
 *             modulus: (optional) if present a random list is generated by
 *                      the use of modulus (element = random() % modulus)
 *                      if not present a list is read from stdin
 * 
 * Input:      If modulus is present none. Otherwise the list.
 * Output:     The sorted list
 * 
 * Debug:      If compiled with the -DDEBUG option, the program outputs:
 *             The sorted sample,
 *             Each threads sorted bucket (its sorted part of the list),
 *             The spitters,
 *             Each thread's list of counts going to each thread from that thread,
 *             Each thread's sorted local list 
 *             
 * Note:       1. Program assumes 1 <= thread_count < s < n. Also, that n and s are
 *                evenly divisible by thread_count
 *           
 *
 * Author:     Henrik Lehmann
 */


#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <math.h>
#include "timer.h"

#define MAX_STR 100
#define SEED1 1
#define SEED2 2

/* Global variables */
int n, s, modulus, thread_count, count = 0;
int *list;
int *splitters;
int *keys_from_thread;
pthread_mutex_t barrier_mutex;
pthread_cond_t ok_to_proceed;



/* Parallel functions */
void* pth_sample_sort(void *rank);

/* Serial functions  */
void Print_list(char *prompt, int *list, int start, int end);
void Gen_list();
void Gen_sample(int sample[]);
void Calc_splitters(int sample[]);
void Read_list(char *prompt);
int Calc_my_list_size(long my_rank);
void Barrier(long my_rank);
int Get_bucket_start(long my_rank, long from_thread);
void Merge_from_threads(int *loc_list, int size, long my_rank, int from_thread);
void Copy_from_bucket(int *loc_list, long my_rank, long from_thread);
void Update_count_list(int my_start, int my_end, long my_rank);
void Sort_my_bucket(int my_buck_start, int my_buck_end, long my_rank);
void Update_list(int *loc_list, int nelts_in_my_list, int my_rank);
void Key_count_init();
int Get_count(long from_thread, long my_rank);
void Usage(char *prog_name);
int Compare_func(const void * a, const void * b);
int Is_chosen(int *chosen, int subscript, int size);
void Get_args(int argc, char **argv, int *n_p, int *s_p, int *t_p, int *m_p); 
int Check_sorted(int list[], int n);

int main(int argc, char **argv) {
    long thread;
    pthread_t *thread_handles;
    int *sample;
    double start, finish;

    Get_args(argc, argv, &n, &s, &thread_count, &modulus);  
    list = malloc(n * sizeof(int));
           
    if(modulus != 0) {
        Gen_list();       
    }    
    else {
        Read_list("Enter list:");
    }

    if (thread_count == 1)
        qsort(list, n, sizeof(int), Compare_func);
    else {
         thread_handles = malloc(thread_count * sizeof(pthread_t));
         sample = malloc(s * sizeof(int));
	 splitters = malloc((thread_count - 1) * sizeof(int));
	 keys_from_thread = malloc(thread_count * thread_count * sizeof(int));
    
	 pthread_mutex_init(&barrier_mutex, NULL);
	 pthread_cond_init(&ok_to_proceed, NULL);

	 /* Set the number of elements to each thread to zero */
	 Key_count_init();
	 
	 Gen_sample(sample);
	 Calc_splitters(sample);
	 
         GET_TIME(start);
	 for (thread = 0; thread < thread_count; thread++) {
	     pthread_create(&thread_handles[thread], NULL, pth_sample_sort, (void*)thread);
	 }
	 GET_TIME(finish);
	 printf("Elapsed time for the sort = %e seconds\n", finish-start);
	 for (thread = 0; thread < thread_count; thread++)
	     pthread_join(thread_handles[thread], NULL);

	 free(thread_handles);
	 free(sample);
	 free(splitters);
	 free(keys_from_thread);
	 
	 pthread_mutex_destroy(&barrier_mutex);
	 pthread_cond_destroy(&ok_to_proceed);

    }
    
    /*    Print_list("After sorting list:", list, 0, n); */
    if (Check_sorted(list, n)) printf("List is sorted\n");
    
    free(list);
  
    return 0;
}






/*----------------------------------------------------------------
 * Function:      pth_sample_sort
 * Purpose:       Sort the global list by using a parallel sample sort
 * In arg:        rank
 * Ret val:       ignored
 * Globals in:    thread_count, n
 * Global in/out: keys_from_thread[], list[] 
 *
 *
 */
void* pth_sample_sort(void *rank) {
    long my_rank = (long)rank;
    int thread, my_buck_start, my_buck_end, my_list_size, nelts_in_my_list = 0;
    int *loc_list, loc_n;
#  ifdef DEBUG    
    char prompt[MAX_STR];
#  endif
    
    /* Get bucket start and end, my_buck_end is not inclusive
    if (my_rank == 0)
        my_buck_start = 0;
    else
        my_buck_start = splitters[my_rank - 1];
    
    if (my_rank == thread_count - 1)
        my_buck_end = n;
    else
        my_buck_end = splitters[my_rank];
    */
    loc_n = n / thread_count;
    my_buck_start = my_rank * loc_n;
    my_buck_end = (my_rank + 1) * loc_n;
    Sort_my_bucket(my_buck_start, my_buck_end, my_rank);
    Update_count_list(my_buck_start, my_buck_end, my_rank);

    /* Make sure every thread has updated the keys_from_thread list*/
    Barrier(my_rank);
    my_list_size = Calc_my_list_size(my_rank);

    loc_list = malloc(my_list_size * sizeof(int));

    /* Copy elements from bucket belonging to thread 0 */
    Copy_from_bucket(loc_list, my_rank, 0);
    nelts_in_my_list += keys_from_thread[my_rank];

    /* Merge elements from the remaining threads */
    for (thread = 1; thread < thread_count; thread++) {
        Merge_from_threads(loc_list, nelts_in_my_list, my_rank, thread);
        nelts_in_my_list += keys_from_thread[thread * thread_count + my_rank];        
    }

#  ifdef DEBUG    
    sprintf(prompt, "Thread %ld > merged list:", my_rank);
    Print_list(prompt, loc_list, 0, nelts_in_my_list);
#  endif

    /* Make sure all threads are done operating on the global list */
    Barrier(my_rank);
    Update_list(loc_list, nelts_in_my_list, my_rank);
    
    free(loc_list);
    
    return NULL;
}






/*----------------------------------------------------------------
 * Function:       Update_list
 * Purpose:        Update the global list so it becomes sorted by having
 *                 each thread write all of its elements to the corresponding
 *                 position in the list 
 *
 * In args:        loc_list, nelts_in_my_list, my_rank
 * Return val:     Ignored
 * Globals in:     thread_count
 * Globals in/out: list[]
 *
 * Note:           Since each thread has a sorted sublist where
 *                 the number of elements can be different from thread
 *                 to thread, each thread need to calculate its start
 *                 in the list. Each thread do this by checking how many keys
 *                 that were assigned to the threads with lower rank than itself.
 *                 For example: if the list of key counts to the various threads
 *                 looks like [2 2 2 1 2 2 0 3 2 3 1 1 0 0 5 2] 
 *                 To thread:  0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3   Then thread 1 will
 *                 calculate the sum of thread 0's counts, 2 + 2 + 2 + 0 = 6 and
 *                 start copying to that position in the global list.
 */
void Update_list(int *loc_list, int nelts_in_my_list, int my_rank) {
    int i, j, size, start_in_list = 0;

    size = thread_count * thread_count;
    /* Calculate position to start copying to in the list */
    for (i = 0; i < my_rank; i++) {
        for (j = i; j < size; j += thread_count) {
            start_in_list += keys_from_thread[j];
        }
        
    }    
    for (i = 0; i < nelts_in_my_list; i++, start_in_list++)
        list[start_in_list] = loc_list[i];
           
}






/*----------------------------------------------------------------
 * Function:   Barrier
 * Purpose:    Synchronize threads
 * In args:    my_rank
 * Global in:  barrier_mutex, ok_to_proceed
 * Return val: Ignored
 *
 * Note:       Only when all threads are in the barrier, threads can
 *             eventually proceed
 */
void Barrier(long my_rank) {
  
    pthread_mutex_lock(&barrier_mutex);
    count++;
    if (count == thread_count) {
        count = 0;
        pthread_cond_broadcast(&ok_to_proceed);
    }
    else {
        while (pthread_cond_wait(&ok_to_proceed,
                                 &barrier_mutex) != 0);
    }
    pthread_mutex_unlock(&barrier_mutex);
}






/*----------------------------------------------------------------
 * Function:     Copy_from_bucket
 * Purpose:      Copy elements from a thread's bucket into the local 
 *               list of the calling thread
 * In args:      loc_list, my_rank, from_thread
 * In global:    list[]
 * Return val:   Ignored
 *
 * Note:         This function is used in this program to copy the
 *               elements from thread 0 that belongs to the calling thread
 *               Each thread calculates where to start in from_thread's
 *               bucket and copies the number of elements (if any) that 
 *               belongs to it, based on the global keys_from_thread
 */
void Copy_from_bucket(int *loc_list, long my_rank, long from_thread) {
    int num_elts, start_in_bucket, i, j;
    
    start_in_bucket = Get_bucket_start(my_rank, from_thread);    
    num_elts = Get_count(from_thread, my_rank);
        
    j = 0;
    for (i = start_in_bucket; i < start_in_bucket + num_elts; i++, j++) {
        loc_list[j] = list[i];
    }    
}






/*----------------------------------------------------------------
 * Function:    Get_bucket_start
 * Purpose:     Calculate the position in from_thread's bucket where
 *              the first element that belongs to the calling thread exists 
 * In args:     my_rank, from_thread
 * In global:   keys_from_thread[]
 * Return val:  position in from_thread's bucket where the calling thread has
 *              its first element
 *
 * Note:        In order to know where a thread starts it needs to determine 
 *              how many elements in the global list that are preceeding its
 *              starting element.
 *              Example: With 4 threads and 28 elements: Assume thread 0 has
 *              calculated that the following counts goes to each thread 
 *              keys_from_thread = [2, 2, 2, 1, .... ,], then if thread 3 calls 
 *              this function it will find that 1 element belongs to it from thread 0.
 *              Now since thread 0 is responsible for the elements 0 to 6 in the global
 *              list, thread 3 will see that its start in the global list will be
 *              the sum of the preceeding elements: 2 + 2 + 2 = 6, so 6 is returned by
 *              the function. 
 */
int Get_bucket_start(long my_rank, long from_thread) {
    int start_in_bucket = 0, i, my_pos_in_count;

    /* Position in from_thread's keys_from_thread */
    my_pos_in_count = from_thread * thread_count + my_rank;
    for (i = 0; i < my_pos_in_count; i++) {
        start_in_bucket += keys_from_thread[i];
    }

    return start_in_bucket;
}






/*----------------------------------------------------------------
 * Function:    Get_count
 * Purpose:     Get the number of keys from from_thread that belongs
 *              to the calling thread
 * In args:     from_thread, my_rank
 * Global_in:   keys_from_thread[]
 * Return val:  Number of elements that the calling thread has in 
 *              from_thread's bucket
 *
 */
int Get_count(long from_thread, long my_rank) {
    return keys_from_thread[from_thread * thread_count + my_rank];    
}






/*----------------------------------------------------------------
 * Function:     Merge_from_threads
 * Purpose:      Merge elements from other thread to get a sorted 
 *               list 
 * In args:      size, my_rank, from_thread
 * In/out args:  loc_list  
 * Global in:    list[]
 *
 * Note:         This function is used after each thread have collected
 *               elements from thread 0's bucket
 *               Firstly, the number of elements to merge are calculated.
 *               Secondly, where to start the copy from the global list and where
 *               to stop
 *               
 */
void Merge_from_threads(int *loc_list, int size, long my_rank, int from_thread) {
    int i, j, k, copy_from, copy_to, recv_count, *temp_p, size_temp;
    
    recv_count = Get_count(from_thread, my_rank);
    copy_from = Get_bucket_start(my_rank, from_thread);
    copy_to = copy_from + recv_count;
    size_temp = size + recv_count;
    temp_p = malloc(size_temp * sizeof(int));
      
    i = k = 0;
    j = copy_from;

    while (i < size && j < copy_to) {
        if (loc_list[i] <= list[j])
            temp_p[k++] = loc_list[i++];
        else
            temp_p[k++] = list[j++];
    }

    while(i < size)
        temp_p[k++] = loc_list[i++];

    while(j < copy_to)
        temp_p[k++] = list[j++];

    for (i = 0; i < size_temp; i++)
        loc_list[i] = temp_p[i];

    free(temp_p);
}






/*----------------------------------------------------------------
 * Function:      Key_count_init
 * Purpose:       Initialize every element in list of key counts to 0
 * In args:       None
 * Global in/out: keys_from_thread[]
 * 
 * Note:          This function should be called before the function
 *                Update_count_list
 */
void Key_count_init() {
    int i, size;

    size = thread_count * thread_count;
    for (i = 0; i < size; i++)
        keys_from_thread[i] = 0;
}






/*----------------------------------------------------------------
 * Function:      Calc_my_list_size
 * Purpose:       Calculate the calling thread's list size, that is 
 *                the number of elements that it should receive from
 *                the other threads including itself
 *
 * In args:       my_rank
 * Global in:     thread_count, keys_from_thread[]
 * Return val:    The number of elements that totally belongs to the calling
 *                thread
 *
 * Note:          Before calling this function the programmer needs to make
 *                sure that the global array keys_from_thread[] has been updated
 *                by each thread, this is done using a barrier
 */
int Calc_my_list_size(long my_rank) {
    int i, start, end;
    int num_elts = 0;

    start = my_rank;
    end = thread_count * (thread_count - 1) + my_rank;
    
    for (i = start; i <= end; i += thread_count)
        num_elts += keys_from_thread[i];
    
    return num_elts;
}






/*----------------------------------------------------------------
 * Function:       Update_count_list
 * Purpose:        Update the global array keys_from_thread[] so it
 *                 contains the number of elements that belong to each
 *                 thread 
 * In args:        my_buck_start: the start of a thread's bucket in the 
 *                                global list
 *                 my_buck_end:   the end of the bucket
 *                 my_rank:       a thread's rank
 * 
 * Global in:      thread_count, list[], splitters[]
 * Global in/out:  keys_from_thread[]
 * Return val:     Ignored
 *
 * Details:        The keys_from_thead[] has a size of thread_count * thread_count
 *                 and each thread is responsible for thread_count elements each
 *                 where the first thread has the first thread_count elements and
 *                 the second thread the next thread_count elements and so on.
 *
 *                 Assume the program is run with 4 threads, and following input:
 *                 the list: [13, 17, 12, 4, 21, 23, 2, 28, 3, 22, 6, 7, 25, 8,
 *                            10, 5, 1, 24, 9, 11, 16, 18, 20, 27, 19, 15, 26, 14]
 *                 the splitters: [7, 14, 22]
 *                 Then the threads will responsible for the following elements (after sorting)                 
 *
 *                 Th 0: 2 4 12 13 17 21 23
 *                 Th 1: 3 6 7 8 22 25 28
 *                 Th 2: 1 5 9 10 11 16 18 24
 *                 Th 3: 14 15 19 20 26 27
 *
 *                 Then if this function is called by thread 0 it will be called with:
 *                 my_buck_start = 0, my_buck_end = 7, my_rank = 0.
 *
 *                 Then, my_start = 0, my_end = 4
 *                 Now, the number of elements in thread 0's bucket
 *                 that belong to each thread is calculated by using the 
 *                 splitters [7, 14, 22] so while the elements in the bucket
 *                 are less than the first splitter 7 it belongs to thread 0, and soon
 *                 So the threads should get:  Th 0: 2 4
 *                                             Th 1: 12 13
 *                                             Th 2: 17 21
 *                                             Th 3: 23
 *
 *                 So after the call to this function keys_from_thread[] looks like:
 *                 [2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0. 0] assuming no other thread
 *                 has called this function
 */
void Update_count_list(int my_buck_start, int my_buck_end, long my_rank) {
    int i, j, k, my_start;
#  ifdef DEBUG    
    char prompt[MAX_STR];
#  endif
    /* Get start in keys_from_thread[] */
    my_start = my_rank * thread_count;
    
    k = my_start;
    i = my_buck_start;
    for (j = 0; j < thread_count - 1; j++) {
        while (list[i] < splitters[j] && i < my_buck_end) {
            keys_from_thread[k]++;
            i++;
        }           
        k++;
    }
    
    /* Everything here belongs to the last bucket (last thread) */
    for (; i < my_buck_end; i++)
        keys_from_thread[k]++;

#  ifdef DEBUG
    sprintf(prompt, "Thread %ld > list of counts:", my_rank);
    Print_list(prompt, keys_from_thread, my_start, my_start + thread_count);
#  endif
}






/*----------------------------------------------------------------
 * Function:       Sort_my_bucket
 * Purpose:        Sort each thread's bucket which are sublists of the
 *                 global list
 * In args:        my_buck_start: where to start in the global list
 *                 my_buck_end:   where to stop based on the number of
 *                             elements that is in a thread's bucket
 *                 my_rank:       rank of thread
 *
 * Global in/out:  list[]
 * Return val:     Ignore
 *
 * Note:           Each thread operates directly on the global list[] and
 *                 sorts its part so a thread's bucket is a sublist of the
 *                 global list[]
 *
 */
void Sort_my_bucket(int my_buck_start, int my_buck_end, long my_rank) {
    int nelts = my_buck_end - my_buck_start;
#  ifdef DEBUG    
    char prompt[MAX_STR];
#  endif  
    qsort(&list[my_buck_start], nelts, sizeof(int), Compare_func);  
    
#  ifdef DEBUG
    sprintf(prompt, "Thread %ld > with sorted bucket:", my_rank);    
    Print_list(prompt, list, my_buck_start, my_buck_end);
#  endif
}






/*----------------------------------------------------------------
 * Function:     Usage
 * Purpose:      Tell the user how to run the program if run incorrectly
 * In args:      prog_name: argv[0]
 *
 * Note:         The program terminates after this function call
 *
 */
void Usage(char *prog_name) {
    fprintf(stderr, "usage: %s <number of threads> <n> <s> <m>\n", prog_name);
    fprintf(stderr, "   n: number of elements\n");
    fprintf(stderr, "   s: sample size\n");
    fprintf(stderr, "   m: (optional) if present a random list is generated\n");
    fprintf(stderr, "                 with m as the modulus\n");
    fprintf(stderr, "                 if not present read n elements from stdin\n");
    exit(0);
}






/*----------------------------------------------------------------
 * Function:        Gen_list
 * Purpose:         Generate a random list of ints
 * In args:         None
 * Global in:       modulus: an integer specified by the user
 * Global in/out:   list[]
 *
 *
 */
void Gen_list() {
    int i;
    
    srandom(SEED1);
    for (i = 0; i < n; i++) {
        list[i] = random() % modulus;
    }   
}






/*----------------------------------------------------------------
 * Function:    Compare_func
 * Purpose:     Compare to integers
 * In args:     a, b
 * Return val:  A positive int if a > b, a negative int if a < b,
 *              and 0 if a == b 
 *
 *
 *
 */
int Compare_func(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}






/*----------------------------------------------------------------
 * Function:     Is_chosen 
 * Purpose:      Check if the subscript has already been chosen
 * In args:      chosen:    array of subscripts that have been choosen
 *               subscript: subscript to look for in the array chosen
 *               size:      the size of the array chosen
 *
 * Return val: 1 (true) if the subscript is in chosen, 0 (false) else 
 *
 *
 */
int Is_chosen(int *chosen, int subscript, int size) {
    int i;

    for (i = 0; i < size; i++) {
        if (chosen[i] == subscript)
            return 1;
    }

    return 0;
}






/*----------------------------------------------------------------
 * Function:       Gen_sample
 * Purpose:        Generate a random sample of the global list[]
 * In/out args:    sample
 * Global in:      list[]
 *
 * Note:           This function takes a sample from the global list[]
 *                 by computing unique subscripts
 *
 *
 */
void Gen_sample(int sample[]) {
    int i, subscript, chosen[s];

    srandom(SEED2);
    for (i = 0; i < s; i++) {
      subscript = random() % n;
        while (Is_chosen(chosen, subscript, i))
            subscript = random() % n;
        sample[i] = list[subscript];
        chosen[i] = subscript;        
    }
    
    qsort(sample, s, sizeof(int), Compare_func);
    
#  ifdef DEBUG
    Print_list("Sample list:", sample, 0, s);
#  endif 
}






/*----------------------------------------------------------------
 * Function:      Calc_splitters
 * Purpose:       Calculate the thread_count - 1 splitters
 * In args:       sample
 * Global in/out: splitters[]
 *
 * Note:          This function calculates the splitters based on
 *                the sorted global sample list, so the global sample
 *                must be provided before calling this function.
 *                The splitters are calculated by taking the ceiling:
 *                splitters[0]     = (sample[s/t - 1] + sample[s/t]) / 2 
 *                splitters[1]     = (sample[2*s/t - 1] + sample[2s/t] / 2
 *                     .                   .                  .
 *                splitters[t - 2] = (sample[(t-1)*s/t - 1] + sample[(t-1)*s/t]) / 2 
 * 
 *                t = thread_count and s = sample size
 *                
 *                Threads  |  Bucket elements
 *                Th 0     | [-inf, splitters[0])
 *                Th 1     | [splitters[0], splitters[1])
 *                  .      |            .
 *                  .      |            .
 *                Th t - 1 | [splitters[t - 2], inf)
 *
 */
void Calc_splitters(int sample[]) {
    int per_bucket = s / thread_count;
    int i, j;
    
    for (i = 0; i < thread_count - 1; i++) {                    
        j = (i + 1) * per_bucket;
        splitters[i] = ceil((sample[j - 1] + sample[j]) / 2.0);        
    }

#  ifdef DEBUG
    Print_list("Splitter list:", splitters, 0, thread_count - 1);
#  endif
}






/*----------------------------------------------------------------
 * Function:    Print_list
 * Purpose:     Print various list of integers to stdout
 * In args:     prompt, list
 * 
 */
void Print_list(char *prompt, int *list, int start, int end) {
    int i;

    if (list != NULL) {
        printf("%s\n", prompt);
        for (i = start; i < end; i++) {
            printf("%d ", list[i]);
        }
        printf("\n");
    }    
}






/*----------------------------------------------------------------
 * Function:       Read_list
 * Purpose:        Read in a list of ints from stdin
 * In args:        prompt
 * Global in/out:  list[]
 *
 */
void Read_list(char *prompt) {
    int i;
    printf("%s\n", prompt);
    for (i = 0; i < n; i++) {
        scanf("%d", &list[i]);
    }
}






/*----------------------------------------------------------------
 * Function:     Get_args
 * Purpose:      Get the command line arguments
 * In args:      argc, argv
 * In/out args:  n_p, s_p, t_p, m_p            
 *             
 */
void Get_args(int argc, char **argv, int *n_p, int *s_p, int *t_p, int *m_p) {
    if (argc != 4 && argc != 5) Usage(argv[0]);

    *t_p = strtol(argv[1], NULL, 10);
    *n_p = strtol(argv[2], NULL, 10);
    *s_p = strtol(argv[3], NULL, 10);
    
    if(argc == 5)
      *m_p = strtol(argv[4], NULL, 10);
    else
      *m_p = 0;
      
}






/*---------------------------------------------------------------------
 * Function:   Check_sorted
 * Purpose:    Determine whether the list is sorted in increasing order
 * In args:    all
 * Ret val:    1 if the list is sorted, 0 otherwise
 */
int Check_sorted(int list[], int n) {
    int i;

    for (i = 0; i < n-1; i++)
        if (list[i] > list[i+1]) {
            printf("list isn't sorted: list[%d] = %d > %d = list[%d]\n",
		   i, list[i], list[i+1], i+1);
	    return 0;
	}
    return 1;
}
